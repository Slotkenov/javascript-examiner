% verslag analyse onderzoekcontext, plusminus 5 pagina's

\section{Introduction}
% Research group: IDEAS
% Tool: Ask- Elle
% Focus: research question 2 and 3: easily adding and finetuning exercises by a 
% tutor 
% Corresponding requirements:
%  - The tutor should be able to create an exercise (...)
%  - Code Layout definition
%  - Programming guidelines definition

The starting point of the 
\gls{examiner} project is pragmatic rather then scientific. 
The urge to reduce labor intensity while maintaining or even improving the 
extent of providing \gls{feedback} has little scientific value by itself. From 
this perspective, it may be argued there is no scientific context, or at least 
no computer science related scientific context. This does by no means degrade 
the scientific value of this project, it just denotes the research context is 
to be found elsewhere. 


The domain research has a practical focus for the greatest part. The 
importance of this approach is clear, when keeping the goal (a functioning 
prototype of the \gls{examiner}) in mind. Whereas the Design Recipe and 
Feedback papers are merely focused on some aspects of the domain, the 
Semantics paper reveals a more fundamental question. In order to get beyond 
the checking of rudimentary characteristics (like functionality, format and 
syntax) it is necessary to reason on \gls{js}, or even on programming 
languages in general, itself. Of course, it is way beyond our limits to pursue 
this reasoning to its foundations. Luckily, this is no unexplored domain.


The main stakeholder of this project directed us towards the IDEAS framework, 
% reference
which is the core for a set of \glspl{domainreasoner}. After broadly studying 
\citep{gerdes2012ask} and \citep{heeren2010specifying} their approaches (with 
regards to semantic analysis) revealed some possible relevant pointers. The 
IDEAS framework is used to generate feedback on input from a specified domain. 
The domain may vary, as the first article is about \gls{haskell}, whereas the 
second is about rewriting strategies for logic expressions.


Both articles describe research projects that focus, like our project, on
providing feedback for (academic) students. In particular, the former article
strengthens the relevance, by putting the usability and maintainability for 
tutors as its central research question. Thus, the goals to our project are 
very much alike. 


When considering their approach, there is one fundamental difference. The IDEAS
framework is designed to provide stepwise feedback. Instead of reviewing a
submitted solution as being complete, it is possible to review a partial 
solution. This feature is deliberately no part of our project. Still, it is 
not unthinkable that there might be successive projects to extend the \gls{
examiner} with this feature. Like our approach, the developed domain reasoners 
are built as prototypes at first.


In order to be able to provide feedback on partial solutions, a thoughtful and 
sophisticated reasoning on the domain specific language semantics is 
necessary. 


We found Heeren, B. willing to discuss with us some aspects of the IDEAS 
project. Since our project has been presented as being the start of a new and 
autonomous project, the scope and aim for the consult has been fairly general. 
We are primarily interested in the conceptual considerations and scientific 
foundations (in particular on semantic evaluation) rather than focused on the 
pure technical specifications. Eventually, this interest led to an, from our 
experience, interesting and fruitful consult. 

In what follows, the consult will be described. As will become apparent, some 
interesting topics will pass. As a result, a brief examination of one of these 
topics will follow. In conclusion, the consult and examination will be linked 
to our project. Furthermore, some interesting topics will be hinted for 
possible succeeding projects.


\section{Consult}
Due to the nature of our project, the outline and boundaries of this consult 
were not clear beforehand. As mentioned in the introduction, there were two 
main topics. The meeting with Heeren was very open and fluent. We no longer 
used our prepared questions during the conversation. Still, at times the 
conversation spirited away, we used the question to get back to the main 
topic. Since we did not literally recorded the consult, the resume below is an 
interpretation based on the prepared questions, the consult itself and the 
keynotes taken.


After a short introduction on the IDEAS framework and our project, the 
discussion started with a demarcation posted by Heeren, in putting the 
Formative approach of the IDEAS related projects against the Summative 
approach of our project. This distinction is the result of the difference in 
approach. The extent to which our project really is summative, is withheld by 
the way it will be used eventually. Still, it seems to be fruitful to keep 
this distinction alive for now, as the central point (no partial solution 
feedback functionality in our project) is striking.

The reasoners have been 

%Verslag consult.
%Vragen + Antwoorden uitwerken:
%Questions
%  - Is it possible to get insight in the actual process of exercise creation?
%  - How many exercises have been created by tutors? 
%  - How is their reception of the exercise creation process? (research already 
% in progress?)
%     * What are the difficulties they experience?
%     * Are their didactic aspects they can't, but would like to introduce? 
%     * What features are used most? (i.e. Global vs Location specific)
%  - What were the arguments to work with model solutions? Have other 
% possibilities
%    been considered? (i.e. test suites)
%  - Is there a limit for the magnitude of an exericse? What are implications 
% (towards possibilities, scope etc.)?
%  - Would it be possible to create a set of exercises in a way there is no need
 % for additional material?
%  ? Are there indicators for a tutor on which constructs feedback annotations 
% are needed? How does
%    the retrieve these indicators?
%  - Is there a size limit or minimum for a  provided set of model solutions?
%  - The correctness is based on equality. Is the current measure method to 
% determine (in)equality rightly balanced?
%  - Is it possible to get a demo on actually adding a simple exercise?
%  - Is Ask-Elle flexible in usage? (mainly in the way exercises are added)
%  - How to proceed if there are 3 model solutions,
%    and two solutions need feedback on the same particular construct,
%    should this feedack annotation be global?
%  - How does Ask-Elle make a distinction between the different solutions (from 
% optimal to suboptimal)?
%    @TODO: meer specifieke vragen (met name hoofdstuk 7 + hoofstuk 5 (feedback 
% scripts))
%  - How are the feedback texts generated?
%    And how do you choose which feedback to show
%    according to the step a student took.
%  - Could the normalization rules be easily ported to JavaScript?
%  - Could the Haskell service be modified to be used for JavaScript code?
%  - Or could the functionality of the Haskell service be ported to JavaScript?
%  - How dificult is it for a tutor
%    to provide the right annotations to a model solution?
%  - Could the annotations used by Ask-Elle be used in the same way
%    for a non-functional language (e.g. JavaScript)?


% Topics of discussion:
%V Formative / Summative distinction
%V Ask-elle (and alike IDEAS implementations) has a more summative approach, 
%V whereas the focus for the Javascript-Examiner for a great part has a formative n
%V Nature.
% Normal form
% Deceitful problem (equality)
% Semantic preserving variations
% http://www.cs.uu.nl/research/techreps/UU-CS-2014-026.html
 % (article Hieke Keuning)
% http://dspace.ou.nl/bitstream/1820/5388/1/INF_20140617_Keuning.pdf 
% (thesis Hieke Keuning)
% Compared to dynamic analysis an inverted approach
% Model solutions
% In the IDEAS approach, more model solutions are required as the exercise expands
% due to the search space (tending to exponential)
% Agorithmic variations (i.e. Quicksort vs Bubblesort)
% Static comparison
% Inverted use of Plagiarism detectors (Juriaan Haring in Java (UU)
% Div tools
% Edit distance

% Implementation 
% Services based
% Modular
% Easily expandable / adaptable
% Solutions
% Collect solutions written by Students for testing the Javascript-Examiner

% Abstract Syntax Tree
% Possibilities to clean the Abstract Syntax Tree at some stage, in order to be 
% able to achieve more accuracy when itâ€™s used for i.e. Semantic Analysis

\section{Semantic Preserving Variations}

% Toetsen aan Javascript in het algemeen

% ????? In hoeverre dit uitwerken ????? Vraag voor Annemiek. ????? Met name 
% gezien het praktische uitgangspunt van Harry en Sylvia.


% From Xu and Chee, explained with the application of IDEAS based reasoner 
% Hieke Keuning
% 1 	Different algorithms
% 2 	Different source code formats
% 3 	Different syntax forms
% 4 	Different variable declarations
% 5 	Different algebraic expression forms 6 Different control structures
% 7 	Different Boolean expression forms 8 Different temporary variables
% 9 	Different redundant statements
% 10 	Different statement orders
% 11 	Different variable names
% 12 	Different program logical structures 
% 13 	Different statements

% Examples:
% SPV1 - Different algorithms (i.e. sorting)
% 	SPV2 - Code format (spaces, indentation, comments)
% 	SPV3 - Syntax forms (if(i) {x = y} else{x = z} or x = (i) ? y : z)
% 	SPV4 - Variable declaration (method / block)
% 	SPV5 - Algebraic expression forms (+ vs --)
% 	SPV6 - Control structures (branching, iterating, traversing)
% 	SPV7 - Boolean expression forms (x == false vs !x (SPV3))
% 	SPV8 - Temporary variables
% 	SPV9 - Redundancy / Code for debugging
% 	SPV10 - Different (statement) order
% 	SPV11 - Diferenent variable names (parameters, functions)
% 	SPV12 - Different logical structures
% 	SPV13 - Different statements

% three forms of representation:

% 	1 - Source Code
% 	2 - AST
% 	3 - Augmented Object-oriented program dependence graph (AOPDG)

% Source-to-specification approach:
% 	-Consistent with Research on program understanding
% 	-Match student code with templates with corresponding specifications OR
% 	-Match student code with specifications like:
% 		*structures
% 		*schemata
% 		*plans
% 		*assertions
% 		*processes
% 	-Moeilijk generaliseren voor alle typen programmeertalen

% Specification-to-specification approach:
% 	-Derive formal specifications from student and reference code
% 	-Not possible for many languages

% Source-to-Source approach:
% 	-performs automatic reasoning at the level of program dependence graphs
% 		(FDG: semantic representation for programs, but no formal specification)

% The Xu and Chee approach:
% 	-Model programs are used as input to the diagnosis of student programs. 
% 	-Comparing student program with model program after standardization 
% (by program transformations)
% 	-transformation-based diagnosis
% 	-Simpler to make use of in practice

% 	-Program standardization and semantic-level program matching
% 	-No intentional checks
	% -Intraprocedural diagnosis method (class hierarchies and inter-procedural 
	% variations are not included)
% 	-Different model programs used to diagnose students program
% 	-correct = being equivalent after standardization
% 	-semantic differences indicate errors

% 	-Computational Semantics vs Operational Semantics


% 	-Standardize programs (representation)
% 	-Match them



 %  Program transformations:

 %  	Basic: (SPV3,4,5,6,7)

 %  	-Statement separation	(remove cascaded messages i.e. var a, b, c = 5);
 %  	-Temporary declaration standardization (declaratie variabelen op bepaalde plaats);
 %  	-Algebraic expression standardization (rules voor notatie berekeningen (normaalvorm));
 %  	-Controle structure standardization (??);
 %  	-Boolean expression standardization (rules voor notatie boolean expressies !x --> x == false);


 %  	Adv:

 %  	-Forward substitution
 %  	-Dead code removal

 %  	3 criteria:

 %  	-Applicable to programs at source code level
 %  	-Covergant (avoid cyclic triggering)
 %  	-Intra-procedural (as limited to intra-procedural)



 %  AOFFG (AUGMENTED Object-Oriented Flow Graph) Program Respresentation

	% -PRG: Program Representation Graphs (Static compile-time semantics) (OFG: Object-oriented Flow Graph for OO)
	% 	*SSA: Static-Single-Assignment
	% 	*PDG: Program Dependence Graphs
	% 		*CDS: Control Dependence Subgraph
	% 		*DDS: Data Dependence Subgraph
	% 	*OPDG: Object-oriented PDG
	%		*PDG
	% 		*ODS: Object Dependence Subgraph
	% 		*ODG: Object based dependence graph		
	% 		*
	% 
	% 	*AOPDG (Augmented Object-oriented Program Dependence Graph) = AOCDS (Augmented Object-oriented Control Dependence Subgraphs) + AODDS (Augmented Object-oriented Data Dependence Subgraphs)(contstructed from AOCDS)
	%  	
	% 	
	% 
	% 	

% Program comparison

	% Partitioned graphs: if vertexSP and vertextMP in same set: statement in vertices semantically equivalent
	% 3 result maps: equivalent map, textual difference map, unmatched map
	% 

% Error detection

	% Problem: Operational semantic differences rather than computational semantic differences
		% --> solution: variation learning process to detect unsystematic semantics-preserving variations
	
\section{Conclusion}

% Mogelijkheden SPV
% In hoeverre wenselijk voor dit project? Wat karakteriseerd JavaScript, en waar is het juist ook niet geschikt voor.... (rapid development vs rigourous analysis (functional math foundational programs)) 
% Handvat voor mogelijke vervolg applicatie.

% In hoeverre tools voorhanden (Uglify )