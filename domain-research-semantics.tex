\documentclass{article} 

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage[square, numbers]{natbib}

\begin{document} 

\title{Domain research --- Semantics}
\author{Boris Arkenaar}
\date{\today}
\maketitle 

% Analyse van kwaliteitsaspecten van code waarop kan worden gecontroleerd,
% uitzoeken hoe deze kunnen worden uitgevoerd.

\section{Introduction} 

Our goal is to make life easier for a programming language teacher. In our
bachelor project we will develop a
JavaScript-examiner\footnote{\url{https://github.com/Slotkenov/javascript-examiner/}}
which will relieve the teacher from checking all students' assignments and
giving them appropriate feedback in an online course. On the other hand the
JavaScript-examiner will be for the benefit of the students as well. The
teacher simply doesn't have time to check the assignments of all the
students. And therefore the teacher cannot give individual feedback to each
student. The teacher will pick the greatest and most common pitfalls he sees in
the assignments he picks at random. Then he will give the students general
feedback on those pitfalls in the next online group session.

The reason why the JavaScript-examiner will benefit students --- besides
relieving the teacher of to much of a workload --- is threefold. First off the
JavaScript-examiner is able to check all the assignments of all students
without any problem. Secondly the JavaScript-examiner can give the students
immediate feedback on their assignment --- in stead of them having to wait for
the next online group session with the teacher. And finally the JavaScript
examiner gives the students individual feedback. In stead of some general
explanation about common pitfalls the student might not even have had trouble
with, the JavaScript-examiner gives each student feedback on the specific
problems encountered in his assignment.

This article will be an analysis of the quality aspects of JavaScript code on
which the JavaScript-examiner can focus. I will look for existing quality
aspects of code and ways of examining those aspects. Those could be aspects for
programming languages in general, or for a specific programming language. I
will determine how they would apply to JavaScript. And maybe there are quality
aspects specific for JavaScript.

The quality aspects will be compared on various points. I will determine how
good they will apply to JavaScript code, and to code from students' assignments
in particular. They will be compared based on how precise they are in their
feedback. And I will base my comparison on how realistic it would be to
implement inspection of those quality aspects in our project. At the end of this article I will formulate a conclusion based on these comparisons, in the form of an advice on which quality aspects to let the JavaScript-examiner examine.

\section{Code quality}

Code quality can be divided into two areas. In one area you look at the quality
of the code itself, without executing it. You look at aspects like how the code
is laid out, how easy it is to read the code and how well you can understand
what the code is trying to do. These aspects have no effect on the execution of
the code however. The second area looks at the quality of execution. How well
does the code execute? Does it use efficient code structures? In this section we will be looking at the first area: the quality of the code.

\subsection{Code layout}

For readability it is important to structure your code in a way that conveys clearly the intention of the code. There are many different ways you could layout your code and there is not one layout that is better than all the others. Most important is consistency.

The easiest way to check for a consistent layout would be if one particular layout would be required form the students. Then the JavaScript-examiner can simply check for that layout. Otherwise it would have to determine the layout of a particular assignment on various aspects and see if that layout is used consistently throughout the entire assignment.

Besides being consistent in using one layout there are still layout aspects
that would be considered bad practice and should be avoided at all times. There
are many tools for examining code to make sure none of these bad practices are
used in a piece of code. Even specific for JavaScript such tools
exist.\footnote{For instance JSLint (\url{http://www.jslint.com/}) and the less
strict variant JSHint (\url{http://www.jshint.com/})}

\subsection{Maintainability}

Various metrics can be used to give an idea about the maintainability of a
piece of code. We are not looking for measuring maintainability specifically,
but an indication of it can help us determine the quality of the code, for
maintainability is an aspect of good quality code. \citet{rakic2013problems}
list the following metrics used in tools for analyzing code:
\begin{itemize}
  \item Lines of code;
  \item Cyclomatic complexity;
  \item Halstead complexity;
  \item Object oriented metrics.
\end{itemize}
We will look at the first three metrics mentioned. The last one --- Object
oriented metrics --- is not too applicable in our case, for JavaScript is not
as object oriented as, for instance, Java is.

First off you can look at the amount of code in terms of lines of code
(LOC). The more lines of code, the more complex it gets. There are different
ways to determine the LOC though. You can simply count all the lines in the
source files, which we will call lines of code (LOC). But you could also skip
the lines which contain comments and empty lines, which we will call source
lines of code (SLOC). Going one step further you can count the actual
statements in the source code in stead of the physical lines. That will give
you the logical lines of code (LLOC). A disadvantage of LLOC is that it is more
difficult to calculate. In stead of simply counting the lines of a text
file. You would need serious knowledge of the programming language in question.

Only looking at the lines of code is not very useful. We can compare the LOC of
the student with the solution of the teacher, but that will give you only a
rough idea about whether the student used far to much code or extraordinarily
few. Next up is cyclomatic complexity. This basically tells you in how many
unique paths your code could be executed \citep{website:js-complexity}. When
the cyclomatic complexity increases, so does the complexity of your code. The
more possible execution paths, the more difficult it is to reason about your
code. The cyclomatic complexity increases when the code base
increases. Therefore it is more useful to express the cyclomatic complexity
relative to the lines of code. This gives us the cyclomatic complexity density
\citep{gill1991cyclomatic}.

The Halstead complexity looks at operators and its operands. It determines the
amount of operators and operands in a piece of code. Besides that it counts the
amount of distinct operators and operands. With that some calculations are
performed to determine the complexity of the code. While a full understanding
of the programming language is not needed, the Halstead method has some
shortcomings as explained by \citet{yu2010survey}. Where the cyclomatic
complexity looks at the control flow of the code, the Halstead methed only
looks at the operations performed, but ignores the control flow completely.

\section{Execution quality}

The quality can be determined by looking at the code structures that have been
used, and by looking at the manner in which the code structures have been
combined.

An interesting way to look at a new programming language can also help us here
to look at JavaScript code, of what structures it is composed and how they are
combined. These words from Abelson and Sussman\footnote{Abelson, H., Sussman,
G.J. 1984 {\em Structure and Interpretation of Computer Programs}. MIT Press,
[\url{https://mitpress.mit.edu/sicp/}]}: ``What are the primitives, what are
their means of combination, and what are their means of abstraction?''

To follow these words we would first have to look at the primitives of
JavaScript. Then we can determine in what ways these primitives can be
combined. Finally we look at the means of abstraction JavaScript offers us.

\subsection{Relative execution time}

For determining the efficiency of the code we can compare the specified
JavaScript code with the correct solution of the teacher. A relatively simple
way could be breaking up the both pieces of code into primitives and determine
the total weight of the code by summing up the weight of each primitives used
in the code. The higher the number the heavier the code, and thus less
efficient. For this method we would have to define beforehand the weight of
each primitive available in JavaScript, according to the relative time it would
take a JavaScript interpreter to interpret that primitive.\footnote{This does
not say anything about readability however. One piece of code code be
marginally more efficient than another, but at the same time be far less
readable, for instance. One would prefer the slightly less efficient one for
its readability. The software would, in this case however, choose the less
readable one.} For this to work you would also need to figure out how many
times a loop is iterated over. The more times a loop is executed, the more time
it would take.

\subsection{Code structures}

When looking at the meaning of the code you can distinguish different code
structures. When you look at an assignment, it might be the case that a good
solution should contain one or two specific code structures. That means that we
can look for those structures in a student's code. If they are not there, or if
there are to much of them, the student can be given feedback mentioning this
fact. In order to be able to give the student a more profound explanation of
why his code is not optimal we would need input form the teacher. Because our
goal is to relieve the teacher from to much work we could try and implement
this feature in a similar way \citet[Section 3.2]{watson2011learning} proposed
in their article. They describe a way to provide feedback on how to correct a
piece of code that generates an error. The first time the system encounters a
specific error it has to request the teacher for feedback. The system saves
that feedback into a database along with the error. On any subsequent
occurrence of that same error in any of the students' code the system retrieves
the teacher's feedback from the database. It does not need to bother the
teacher while the student receives valuable feedback.

We would need to determine first what code structures are important. When a
student uses a for loop where the teacher does not, that would be an
interesting case. But when a student uses one more simple assignment statement
than the teacher, that will probably not be very important for instance. We can
determine the set of primitives used in the code, by type and by quantity. And
compare that with the solution of the teacher. This gives us a set of
primitives the student did not use while the teacher did, and of the other way
around. After filtering these two sets of primitives for important ones we have
something to give feedback on. Now we can use the same mechanics as
\citet{watson2011learning} described. We look in the database for the feedback
on a particular primitive that was used --- or not used --- and give that to
the student. In case no feedback was found in the database, the teacher is
requested for input.

Research would be needed to see if this would work the way I describe it
here. Would it be feasible to determine how to rate the primitives of the
JavaScript language? And would the system find all the problem cases or will it
miss some, or find cases that are of no importance? Besides that this functionality would have to be created from the ground up because it is quite specific and I have not found something like it for JavaScript.

\section{Comparing code}

The great thing is: we do not need to determine the quality of a piece of code
on its own. We can compare it to well defined base piece of code that is
assumed to be correct and efficient (i.e. an acceptable solution). That means
that we do not need to decide how many lines of code would be too much, or what
cyclomatic complexity would make the code too complex. We can just compare the
lines of code, and the halstead complexity of the student's code with the
solution of the teacher. We do have to determine however, how bad is the code
if it is not as good as the solution of the teacher. There should probably be
some margin of acceptance.

\subsection{Definition of an assignment}

The teacher has to start by defining an assignment. He formulates a description
of the assignment and creates some unit tests. He also creates a solution
appropriate for the assignment that should also pass the tests he created. At
this point we have the data needed for the student to be able to read the
assignment and start working, and for the software to be able to determine if a
piece of JavaScript code is functionally correct. We can also check the quality
of the JavaScript code which is independent of the assignment.

When we start looking at maintainability and execution time, we need to compare
the results of those aspects with the solution of the teacher. Therefore we
need the teacher to give a possible solution to the system in order for it to
be able to determine some base level in these quality aspects which are
acceptable. For looking at code structure we might need to go further and ask the teacher to specify which primitives used in his solution are important. And maybe he could also specify some primitives the students might be tempted to use in stead of the primitives the teacher used.

\section{Conclusion}

\bibliographystyle{abbrvnat}
\bibliography{bibliography}

\end{document}
