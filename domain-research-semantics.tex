\documentclass{article} 

\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage[round]{natbib}

\begin{document} 

\title{Domain research --- Semantics}
\author{Boris Arkenaar}
\date{\today}
\maketitle 

Introduction
Code layout
Code quality
  Relative execution time
  Metrics
Comparing code
Conclusion

\section{Introduction} 

Before we get tho this phase, the Javascript code has passed the tests for
syntax and the unit tests for functionality. So we know the code runs and it
gives the correct output for a certain input.

Semantics can be divided into two areas.

\section{Code layout}

The layout of the code. Well indented, always using semicolons and curly
braces. This can be checked with a tool like
JSHint\footnote{\url{http://www.jshint.com/}}.

\section{Code quality}

The quality can be determined by looking at the code structures that have been
used, and by looking at the manner in which the code structures have been
combined.

An interesting way to look at a new programming language can also help us here
to look at Javascript code, of what structures it is composed and how they are
combined. These words from Abelson and Sussman\footnote{Abelson, H., Sussman,
G.J. 1984 {\em Structure and Interpretation of Computer Programs}. MIT Press,
[\url{https://mitpress.mit.edu/sicp/}]}: ``What are the primitives, what are
their means of combination, and what are their means of abstraction?''

To follow these words we would first have to look at the primitives of
Javascript. Then we can determine in what ways these primitives can be
combined. Finally we look at the means of abstraction Javascript offers us.

\subsection{Relative execution time}

For determining the efficiency of the code we can compare the specified
Javascript code with the correct solution of the teacher. A relatively simple
way could be breaking up the both pieces of code into primitives and determine
the total weight of the code by summing up the weight of each primitives used
in the code. The higher the number the heavier the code, and thus less
efficient. For this method we would have to define beforehand the weight of
each primitive available in Javascript, according to the relative time it would
take a Javascript interpreter to interpret that primitive.\footnote{This does
not say anything about readability however. One piece of code code be
marginally more efficient than another, but at the same time be far less
readable, for instance. One would prefer the slightly less efficient one for
its readability. The software would, in this case however, choose the less
readable one.} For this to work you would also need to figure out how many
times a loop is iterated over. The more times a loop is executed, the more time
it would take.

\subsection{Maintainability}

Various metrics can be used to give an idea about the maintainability of a
piece of code. We are not looking for measuring maintainability specifically,
but an indication of it can help us determine the quality of the code, for
maintainability is an aspect of good quality code.

First off you can look at the amount of code in terms of lines of code
(LOC). The more lines of code, the more complex it gets. There are different
ways to determine the LOC though. You can simply count all the lines in the
source files, which we will call lines of code (LOC). But you could also skip
the lines which contain comments and empty lines, which we will call source
lines of code (SLOC). Going one step further you can count the actual
statements in the source code in stead of the physical lines. That will give
you the logical lines of code (LLOC). A disadvantage of LLOC is that it is more
difficult to calculate. In stead of simply counting the lines of a text
file. You would need serious knowledge of the programming language in question.

Only looking at the lines of code is not very useful. We can compare the LOC of
the student with the solution of the teacher, but that will give you only a
rough idea about whether the student used far to much code or extraordinarily
few. Next up is cyclomatic complexity. This basically tells you in how many
unique paths your code could be executed\citep{website:js-complexity}. When the
cyclomatic complexity increases, so does the complexity of your code. The more
possible execution paths, the more difficult it is to reason about your code.

\citet{rakic2013problems} list the following metrics used in tools for
analyzing code:

\begin{itemize}
  \item Cyclomatic complexity
  \item Halstead metrics
  \item Lines of code
  \item Object oriented metrics
\end{itemize}

\section{Comparing code}

\subsection{Definition of an assignment}

The teacher has to start by defining an assignment. He formulates a description
of the assignment and creates some unit tests. He also creates a solution
appropriate for the assignment that should also pass the tests he created. At
this point we have the data needed for the student to be able to read the
assignment and start working, and for the software to be able to determine if a
piece of Javascript code is functionally correct. We can also check the quality
of the Javascript code which is independent of the assignment.

\section{Conclusion}

\bibliographystyle{plainnat}
\bibliography{bibliography}

\end{document}
