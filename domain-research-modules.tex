

-In plaats van Workshopper zouden we mogelijk ook gebruik kunnen maken van Adventure. Wat het exacte verschil is weet ik overigens ook niet precies.

Verder ziet het er goed uit, wellicht moet er nog iets meer een argumentatiestructuur in komen waar we de uiteindelijke keuze in de conclusie verantwoorden.

In aanvulling op het laatste bericht: de inleiding zou nog info kunnen geven over de (niet) functionele requirements.

\documentclass{article}
\usepackage{hyperref}
\begin{document}
\title{Domain Research}
\author{Ronald Kluft}
\date{\today}
\maketitle

%TODO: Is het relevant om steeds te vermelden hoe het wordt geinstalleerd?

\section{Introduction}
This domain research is a first orientation on the use of existing frameworks that can be used in the 
project to construct the JavaScript-examiner\footnote{\url{https://github.com/Slotkenov/javascript-examiner/}}.
Because of the limited time, I have started with the frameworks that are mentioned in 
'Web applications: The Client Side'\footnote{\url{http://www.ou.nl/studieaanbod/T58221}}.
The application under development will be open-source, so the frameworks should also be available
under an open-source license.

\subsection{Mocha}
"Mocha is a feature-rich JavaScript test framework running on node.js and the 
browser, making asynchronous testing simple and fun."\footnote{\url{http://www.mochajs.org}}.
It can be installed with NPM (Node Packaged Modules)\footnote{\url{https://www.npmjs.org}}.
The options can be given at the command line, or in a special options file.
%TODO: wat bedoel je met de onderstaande zin? Hoe werkt het precies en wat is er voor nodig?
It states that it can use any assertion library (like should.js, Chai etc.), 
the only thing it needs to work together is that the library can throw an error.
%TODO: Waarom is het niet nuttig voor de kleinere opgaven in het begin?
The Mocha framework can be of great use when the code under test will become more complex and can be submitted to unit tests.
This because the number of lines of code will be small in comparison with the effort of making a test.
Mocha states that the use of the command-line van run into some problems, if you want to load specific files. 
But it doesn't explain what these problems might be.

\subsection{Chai}
"Chai is a BDD/TDD assertion library for node and the browser that can be delightfully paired with any JavaScript testing framework"\footnote{http://chaijs.com}.
Chai can be installed with NPM.
It is well documented and there are ways to extend it with your own assertions by making plugins,
but you can do this after you have a solid knowledge of Chai.
It requires knowledge of he Assert style, the BDD style (Behaviour-driven development, based on TDD. BDD comes in two flavors, expect and should. With this you can write a test that lookes like natural language) and/or the TDD style (Test Driven Development, writing tests that initially fail, and then produce a minimal amount of code that passes the test) assertion style language, because these are the three assertion styles that may be used in the testing environment.
Therefore it may be used later in the project, but it can also be a subject of a new research.

\subsection{JSLint}
The JavaScript Code Quality Tool\footnote{http://www.jslint.com}\\
It is a static code analysis tool.
NPM can be used to install JSLint.
JSLint can operate on JavaScript source or JSON (JavaScript Object Notation)\footnote {http://www.json.org} text.
JSLint defines a professional subset of JavaScript, a stricter language than that 
defined by Third Edition of the ECMAScript Programming Language Standard.
The subset is related to recommendations found in Code Conventions for the JavaScript Programming Language.
The default settings are too strict for our purpose.
For instance, it gives errors when there are no spaces on either side of an equal sign.

\subsection{JSHint}
"JSHint is a community-driven tool to detect errors and potential problems in JavaScript code and to enforce your team's coding conventions. It is very flexible so you can easily adjust it to your particular coding guidelines and the environment you expect your code to execute in."\footnote{http://www.jslhint.com/about}
It can be installed with NPM.
JSHint can be configured with enforcing options and relaxing options.
The first, when set to true, produces more warnings. Whereas the latter produces less warnings about the code.
Because JSHint is not as strict as JSLint, it is a more suitable option for the JavaScript-examiner.

\subsection{HJS}
"A Javascript parser and interpreter. Works as per ECMA-262 plus some parts of JS $>=$1.5.
HJS is a JavaScript parser written in Haskell. Available from HackageDB."\footnote{https://hackage.haskell.org/package/hjs}
Because Haskell is also a subject of an Open University course\footnote{http://www.ou.nl/studieaanbod/T12331}, I have searched for a tool in Haskell.
It seems that because Haskell is a functional language which can evaluate functions at high speed, it is a good candidate for a parser.
But my knowledge of Haskell is not sufficient to give a thorough opinion on this.

\subsection{Escomplex}
"Software complexity analysis of JavaScript-family abstract syntax trees. The back-end for complexity-report"\footnote{\url{https://github.com/philbooth/escomplex}}.
NPM can be used to install Escomplex.
An AST (abstract syntax tree), represents the code as a tree, with the variables as leafs and keywords, assignments, equations etc. as nodes.
This can be useful to see what construct is used at a given point in the code.

\subsection{Esprima}
"Esprima is a high performance, standard-compliant ECMAScript parser written in ECMAScrip."\footnote{\url{http://esprima.org}}\\
Esprima can be installed on Rhino, Nashorn, and Node.js.
It can return a syntax tree that conforms to the format defined in Mozilla's Parser API, which can be the input for Escomplex.
Esprima's purpose is only to check for syntax errors.

\subsection{Acorn}
"Acorn is a tiny, fast JavaScript parser written in JavaScript."\footnote{\url{http://marijnhaverbeke.nl/acorn/}}\\
Acorn returns an abstract syntax tree as specified by Mozilla parser API, which can be used as input for escomplex.
With a second optional argument the parser process can be further configured.
The advantage of Acorn is that it is tiny. About half as big as Esprima, in lines of code.

\subsection {Firebug Lite}
Light version of Firebug (an add-on for Firefox), completely written in JavaScript.
I think the usability for our project is minimal, because you use it as a web-app, or a plug-in.

\section{Platform}
To understand the use of the tools, we should look into the platform that can be used.\\
I have looked at Node.js, Rhino and Nashorn.

\subsection{Rhino}
"Rhino is a JavaScript interpreter written in Java and designed to make it easy to write JavaScript programs 
that leverage the power of the Java platform APIs."\footnote{\url{JavaScript, The Definitive Guide, David Fanagan, O'Reilly}}\newline
http://en.wikipedia.org/wiki/Rhino\_(JavaScript\_engine)
https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino

\subsection{Node.js}
"Node is a fast C++ based JavaScript interpreter with bindings to the low-level 
Unix APIs for working with processes, files, network sockets, etc., and also to 
HTTP client and server APIs."\footnote{\url{http://nodejs.org}}
Node.js can be used to build and run JavaScript applications, without the need of a browser.
A numerous amount of the tools run on Node.js \footnote{http://www.nodejs.org}. This is well know platform.
Node.js runtime is available for different operating systems.
There is a version for Unix, Linux, Windows and Mac.\\
Tools that can be installed on Node are fairly easy to install. The command install package -g does the trick.\\
Node.js can be a useful tool because it can run locally on a development computer, and also can be installed on a webserver.
This way the JavaScript-examiner can be exposed via the browser.

\subsection{Nashorn}
"Nashorn's goal is to implement a lightweight high-performance JavaScript runtime in Java with a native JVM.
This Project intends to enable Java developers embedding of JavaScript in Java applications via JSR-223 and to develop 
free standing JavaScript applications using the jrunscript command-line tool."\footnote{\url{http://openjdk.java.net/projects/nashorn/}}
The use of a command-line tool to develop JavaScript applications is not our goal.

\section{Environment}
\subsection{Workshopper}
With workshopper on Nodeschool.IO\footnote{\url{http://nodeschool.io/}} it is possible to create your own menu-driven learning environment. 
Workshopper can be installed with node.js.
It is also covered in the paper of Bram Nieuwenhuize\footnote{domain-research-feedback.pdf}
You can generate a simple menu structure interface with workshopper.
, it is a good option to use in 
%TODO: Alleen in het begin? Wat kunnen we precies gebruiken en hoe?
the beginning of the development of the JavaScript-examiner.

-De Workshopper module is gericht op lokaal gebruik. Op het moment dat we bijvoorbeeld bepaalde statistieken willen gaan loggen (om inzicht te creÃ«ren van veel gemaakte fouten voor de docent bijvoorbeeld) en we de Workshopper willen gebruiken, zullen we dus aanpassingen moeten maken. We hoeven nu nog niet te weten welke aanpassingen precies maar het is wellicht aardig om er bij stil te staan. Het opensource karakter is wat dat aangaat interessant. 

\section{Conclusion}
Because the first version of the JavaScript examiner can not contain all the enhanced 
functionality of modules, the best option to start with are modules which can run on Node.js.
This can that we can write our code in JavavScript.
% TODO: Moeten we dit niet min of meer van te voren vaststellen, zodat de architectuur geschikt is? Of bijvoorbeeld
%verantwoorden waarom het prima gaat om dit later te bepalen (hoge compatability van onderlinge tools oid). 
%Daar zou dan een aparte paragraaf voor kunnen komen.
As the software matures, more complex modules can probably be used, but that will be subject of future projects.
The use of a functional language seems also a useful but requires the knowledge of an other language.
%TODO: Waar komt ClojureScript opeens vandaan?
Maybe ClojureScript is capable of doing the same, but I haven't had time to look into this.  

\section{References}

\end{document}
