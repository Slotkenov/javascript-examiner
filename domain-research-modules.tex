\documentclass{article}

\begin{document}

\title{Domain Research}
\author{Ronald Kluft}
\date{\today}
\maketitle

\begin{description}
\section{Introduction}

This domain research is about the modules we can use in our project to construct a JavaScript examiner.\\
There are a lot of modules to be found, but they are all about the JvaScript syntax.
I have not found modules that gives feedback about the construction of the code
There may be information to be gained from information given by a number of modules about the complexity of the code. 
But this is only an indication, and does not make a distinction whether a for or a while should be used.
The difficulty in this research is that to completely understand the possibilities of them, you should extensively use it.
There was not enough time to do this thoroughly.
Mainly because there are a lot of modules, of which a great number are wrappers around other modules to give a nicer report.
There are also a number of testing techniques, but this is out of scope.

\section{Goal}
The goal is to find modules that can be used to detect the errors in the JavaScript code.
A downside at this point is that we don't know yet what environment will be used.
Therefore the search was a bit broader than when this is known.
I first started with the modules that are named in 'Web applications: The Client Side'\footnote{http://www.ou.nl/studieaanbod/T58221}, and after that began a search for other known tools.
The focus of the research is about the usability of the modules in terms of embedding in our project.

The items of consideration are :\\
\item[The name of the module]
\item[The location]
\item[What is does]
\item[omgeving?]
\item[Configurability]
\item[Output]

\item[Mocha]
mocha kan een json report uitspugen, welke gebruikt kan worden om een eigen rapportage te maken of eigen foutmeldingen te genereren.
Mocha runs in the browser. Every release of Mocha will have new builds of ./mocha.js and ./mocha.css for use in the browser. To setup Mocha for browser use all you have to do is include the script, stylesheet, tell Mocha which interface you wish to use, and then run the tests.
A typical setup might look something like the following, where we call mocha.setup('bdd') to use the BDD interface before loading the test scripts, running them onload with mocha.run().\\
http://visionmedia.github.io/mocha/\#browser-support
mocha : http://visionmedia.github.io/mocha/

\item[Chai]
chai  : http://chaijs.com/

should.js BDD style shown throughout these docs
expect.js expect() style assertions
chai expect(), assert() and should style assertions
better-assert c-style self-documenting assert()

\item[JsLint]D www.jslint.com\\Hier kun je code invoeren die vervolgens wordt getest.
https://github.com/douglascrockford/JSLint\\
JSLint can operate on JavaScript source or JSON text.

If JSLint is able to complete its scan, it generates a function report. It lists for each function:
The line number on which it starts.
Its name. In the case of anonymous functions, JSLint will 'guess' the name.
The parameters.
Closure: The variables and parameters that are declared in the function that are used by its inner functions.
Variables: The variables that are declared in the function that are used only by the function.
Exceptions: The variables that are declared by try statements.
Outer: Variables used by this function that are declared in another function.
Global: Global variables that are used by this function. Keep these to a minimum.
Label: Statement labels that are used by this function.
The report will also include a list of all of the property names that were used. There is a list of JSLint messages.

\item[JsHint]
Naam        : jshint
Voorwaarden : npm (is nu een onderdeel van node.js)
aanroep     :
invoer      : The simplest use case would be linting a single file or all JavaScript files in a directory:
              \$ jshint myfile.js
              If a file path is a dash (-) then JSHint will read from standard input.
uitvoer     : myfile.js: line 10, col 39, Octal literals are not allowed in strict mode.
              1 error
platform    : Win, Mac, Linux

http://www.jshint.com/
http://www.jshint.com/docs/reporters/
http://www.mindfiresolutions.com/Use-of-JSLint-to-Verify-JavaScript-48.php
http://www.jslint.com/lint.html
http://jslinterrors.com/api
http://jslinterrors.com/api

\item[HJS]
http://www.haskell.org/haskellwiki/Applications\_and\_libraries/Compilers\_and\_interpreters\#JavaScript
1.21 JavaScript
HJS
HJS is a JavaScript parser written in Haskell. Available from HackageDB.
It runs on a hackage server.
https://hackage.haskell.org/package/language-javascript

\item[Firebug]getfirebug.com
extension for Firefox\\
bruikbaarheid : laag, omdat het een browser extentie is.
Extensibility : Firebug has a number of extensions for various tasks. You can write your own extensions.
write your own test files

\item [Firebug Lite]light version of Firebug, completely written in JavaScript\\
bruikbaarheid : goed, je kunt de sources downloaden en gebruiken i nje eigen projecten.\\
maar niet heus, het heeft geen JavaScript debugger / profiler

\item[Opera Dragonfly]Extension for Opera browser\\
www.opera.com/dragonfly/jscomplexity.org

\item[JScomplexity]jscomplexity.org/
Dit is een wrapper rondom escomplex

\item[Complexity report]https://github.com/philbooth/complexity-report/blob/master/README.md   requires node.js

\item[escomplex]https://github.com/philbooth/escomplex\\
Software complexity analysis of JavaScript-family abstract syntax trees. The back-end for complexity-report.
Kan geinstalleerd worden onder node\\
kan simpel gebruikt worden in de eiegen JavaScript code door middel van een enkele toekenning.\\

\item[Esprima]esprima.org\\
kan ook sources rewrite dat ze er mooi uitzien. Handig voor het makkelijk nakijken.
Dit is een web app
voor command line check esvalidate from Esprima package for Node.js
"Esprima runs on many popular web browsers, as well as other ECMAScript platforms, such as Rhino, Nashorn, and Node.js."[x]
x=https://www.npmjs.org/package/esprima

\item[Acorn]http://marijnhaverbeke.nl/acorn/
The main exported interface (under self.acorn when in the browser) is a parse function that takes a code string\\
Returns an abstract syntax tree as specified by Mozilla parser API, with the caveat that inline XML is not recognized.
A second optional argument can be given to further configure the parser process.

\item[Plato]plato.js\\
is eigenlijk een wrapper rond jsllint en jscomplexity


\section{Environments}
To give a meaningful explanation of tools, it must be understand what the environments can be.\\
A numerous amount of the tools run on node.js \footnote{http://www.nodejs.org}. This is etc.
There is an version for Unix, Linux, Windows and Mac.\\
Tools that can be installed on node are fairly easy to install. The command install package -g does the trick.\\
Node.js, Rhino, Nashorn(openjdk.java.net/projects/nashorn/)

\item[Rhine]Rhino is a JavaScript interpreter written in Java and designed to make it easy to write JavaScript programs that leverage the power of the Java platform APIs.[1]
[1] JavaScript, The Definitive Guide, David Fanagan, O'Reilly\newline
http://en.wikipedia.org/wiki/Rhino\_(JavaScript\_engine)
https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino

\item[Node.js]
http://nodejs.org/
Node is a fast C++ based JavaScript interpreter with bindings to the low-level Unix APIs for working with processes, files, network sockets, etc., and also to HTTP client and server APIs.[1]
Node.js is available for most platforms.

\item[Nashorn]Nashorn(openjdk.java.net/projects/nashorn/)
"Nashorn's goal is to implement a lightweight high-performance JavaScript runtime in Java with a native JVM. This Project intends to enable Java developers embedding of JavaScript in Java applications via JSR-223 and to develop free standing JavaScript applications using the jrunscript command-line tool."

\section{Conclusion}

\section{References}

\end{description}

\end{document}


