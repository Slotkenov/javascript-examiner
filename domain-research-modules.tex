\documentclass{article}

\begin{document}

\title{Domain Research}
\author{Ronald Kluft}
\date{\today}
\maketitle

\section{Introduction}

This domain research is about the modules we can use in our project to construct a JavaScript examiner.\\
There are a lot of modules to be found, but they are all about the JvaScript syntax.
I have not found modules that gives feedback about the construction of the code
There may be information to be gained from information given by a number of modules about the complexity of the code. 
But this is only an indication, and does not make a distinction whether a for or a while should be used.
The difficulty in this research is that to completely understand the possibilities of them, you should extensively use it.
There was not enough time to do this thoroughly.
Mainly because there are a lot of modules, of which a great number are wrappers around other modules to give a nicer report.
There are also a number of testing techniques, but this is out of scope.

\section{Goal}
The goal is to find modules that can be used to detect the errors in the JavaScript code.
A downside at this point is that we don't know yet what environment will be used.
Therefore the search was a bit broader than when this is known.
I first started with the modules that are named in 'Web applications: The Client Side'\footnote{http://www.ou.nl/studieaanbod/T58221}, and after that began a search for other known tools.
The focus of the research is about the usability of the modules in terms of embedding in our project.

The items of consideration are :\\
\begin{itemize}
\item[The name of the module]q
\item[The location]q
\item[What is does]q
\item[omgeving?]
\item[Configurability]
\item[Output]
\item[pro]
\item[con]
\end{itemize}

\subsection{Mocha}
"Mocha is a feature-rich JavaScript test framework running on node.js and the browser, making asynchronous testing simple and fun.
Mocha tests run serially, allowing for flexible and accurate reporting, while mapping uncaught exceptions to the correct test cases."\footnote{http://www.mocha.org}.
It can be installed with npm (Node Packaged Modules)\footnote{https://www.npmjs.org}.
The framework can be configured through an options file.
It uses a It allows you to write testfiles which will be held against your code.
pro : Highly configurable.
con : Requires how to write test files. 
In the first stage of the project It will be, but it is definetely handif

\subsection{Chai}
"Chai is a BDD/TDD assertion library for node and the browser that can be delightfully paired with any javascript testing framework"\footnote{http://chaijs.com}.
n expectation framework. It can be installed with npm.
It is well documented and there are ways to extend it with your own assertions.
It requires knowledge of BDD and/or TDD assertion style language.

\subsection{JsLint}
The JavaScript Code Quality Tool\footnote{http://www.jslint.com}\\
It is a static code analysis tool.
It can be installed with npm.
JSLint can operate on JavaScript source or JSON ((JavaScript Object Notation))\footnote {http://www.json.org} text.
JSLint defines a professional subset of JavaScript, a stricter language than that defined by Third Edition of the ECMAScript Programming Language Standard.
The subset is related to recommendations found in Code Conventions for the JavaScript Programming Language.
Default the tests are too strict for our purpose.

\subsection{JsHint}
"JSHint is a community-driven tool to detect errors and potential problems in JavaScript code and to enforce your team's coding conventions. It is very flexible so you can easily adjust it to your particular coding guidelines and the environment you expect your code to execute in."\footnote{http://www.jslhint.com/about}
It can be installed with npm.
JSHint comes with a default set of warnings but it was designed to be very configurable.
Because of this it is a better option than JsLint.







\subsection{HJS}
http://www.haskell.org/haskellwiki/Applications\_and\_libraries/Compilers\_and\_interpreters\#JavaScript
1.21 JavaScript
HJS
HJS is a JavaScript parser written in Haskell. Available from HackageDB.
It runs on a hackage server.
https://hackage.haskell.org/package/language-javascript

\subsection{Firebug}
getfirebug.com
extension for Firefox\\
bruikbaarheid : laag, omdat het een browser extentie is.
Extensibility : Firebug has a number of extensions for various tasks. You can write your own extensions.
write your own test files

\subsection {Firebug Lite}
light version of Firebug, completely written in JavaScript\\
bruikbaarheid : goed, je kunt de sources downloaden en gebruiken in je eigen projecten.\\
maar niet heus, het heeft geen JavaScript debugger / profiler

\subsection{Opera Dragonfly}
Extension for Opera browser\\
www.opera.com/dragonfly/jscomplexity.org

\subsection{JScomplexity}jscomplexity.org/
Dit is een wrapper rondom escomplex

\subsection{Complexity report}
https://github.com/philbooth/complexity-report/blob/master/README.md   requires node.js

\subsection{escomplex}
https://github.com/philbooth/escomplex\\
Software complexity analysis of JavaScript-family abstract syntax trees. The back-end for complexity-report.
Kan geinstalleerd worden onder node\\
kan simpel gebruikt worden in de eiegen JavaScript code door middel van een enkele toekenning.\\

\subsection{Esprima}
esprima.org\\
kan ook sources rewrite dat ze er mooi uitzien. Handig voor het makkelijk nakijken.
Dit is een web app
voor command line check esvalidate from Esprima package for Node.js
"Esprima runs on many popular web browsers, as well as other ECMAScript platforms, such as Rhino, Nashorn, and Node.js."[x]
x=https://www.npmjs.org/package/esprima

\subsection{Acorn}
http://marijnhaverbeke.nl/acorn/
The main exported interface (under self.acorn when in the browser) is a parse function that takes a code string\\
Returns an abstract syntax tree as specified by Mozilla parser API, with the caveat that inline XML is not recognized.
A second optional argument can be given to further configure the parser process.

\subsection{Plato}
plato.js\\
is eigenlijk een wrapper rond jsllint en jscomplexity


\section{Environments}
To give a meaningful explanation of tools, it must be understand what the environments can be.\\
A numerous amount of the tools run on node.js \footnote{http://www.nodejs.org}. This is etc.
There is an version for Unix, Linux, Windows and Mac.\\
Tools that can be installed on node are fairly easy to install. The command install package -g does the trick.\\
Node.js, Rhino, Nashorn(openjdk.java.net/projects/nashorn/)

\subsection{Rhino}Rhino is a JavaScript interpreter written in Java and designed to make it easy to write JavaScript programs that leverage the power of the Java platform APIs.[1]
[1] JavaScript, The Definitive Guide, David Fanagan, O'Reilly\newline
http://en.wikipedia.org/wiki/Rhino\_(JavaScript\_engine)
https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino

\subsection{Node.js}
http://nodejs.org/
Node is a fast C++ based JavaScript interpreter with bindings to the low-level Unix APIs for working with processes, files, network sockets, etc., and also to HTTP client and server APIs.[1]
Node.js is available for most platforms.

\subsection{Nashorn}Nashorn(openjdk.java.net/projects/nashorn/)
"Nashorn's goal is to implement a lightweight high-performance JavaScript runtime in Java with a native JVM. This Project intends to enable Java developers embedding of JavaScript in Java applications via JSR-223 and to develop free standing JavaScript applications using the jrunscript command-line tool."



\section{Conclusion}
Because we are writing a program for examining javascript, it is handy to use a tool that has been written in JavaScript.
This prevents from learning an additional language.

\section{References}

\end{document}


